
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_gallery/plot_annihilation_cross_section.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_gallery_plot_annihilation_cross_section.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_gallery_plot_annihilation_cross_section.py:


Annihilation cross section
==========================

Calculate the annihilation cross section, :math:`\langle \sigma v \rangle` for the various annihilation channels of the model.

.. GENERATED FROM PYTHON SOURCE LINES 7-12

.. code-block:: default


    import matplotlib.pyplot as plt
    import numpy as np
    from singletscalar_dm import *








.. GENERATED FROM PYTHON SOURCE LINES 13-15

In order to calculate the annihilation cross section you can use the function: `sigmav_channels`.
The example below calculates the annihilation cross section for the channel `'bb'`.

.. GENERATED FROM PYTHON SOURCE LINES 15-21

.. code-block:: default


    mS = 70 # GeV
    lambda_hs = 0.01
    sigmav_bb = sigmav_channels(mS,lambda_hs,'bb')
    print(sigmav_bb)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1.346728994901666e-28




.. GENERATED FROM PYTHON SOURCE LINES 22-24

The possible choices for the channels are: `'cc'`, `'bb'`, `'tt'`, `'tautau'`, `'gg'`, `'ww'`, `'zz'`, `'hh'`, `'aa'`, `'za'`.
It is possible to specify `'tot'` to take into account all the previous channels together.

.. GENERATED FROM PYTHON SOURCE LINES 24-30

.. code-block:: default


    mS = 200 # GeV
    lambda_hs = 0.01
    sigmav_tot = sigmav_channels(mS,lambda_hs,'tot')
    print(sigmav_tot)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    4.680000000006868e-28




.. GENERATED FROM PYTHON SOURCE LINES 31-32

This is equivalent to summing all the different channels together.

.. GENERATED FROM PYTHON SOURCE LINES 32-41

.. code-block:: default


    mS = 200 # GeV
    lambda_hs = 0.01
    sigmav_tot = 0
    channels_vec = np.array(['cc','bb','tt','tautau','gg','ww','zz','hh','aa','za'])
    for t in range(len(channels_vec)):
        sigmav_tot += sigmav_channels(mS,lambda_hs,channels_vec[t])
    print(sigmav_tot)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    4.668283600003697e-28




.. GENERATED FROM PYTHON SOURCE LINES 42-43

It is possible to calculate the relative contribution of the different channels to the total cross section.

.. GENERATED FROM PYTHON SOURCE LINES 43-67

.. code-block:: default


    Br_cc = np.zeros(len(massz_vec))
    Br_bb = np.zeros(len(massz_vec))
    Br_tt = np.zeros(len(massz_vec))
    Br_tautau = np.zeros(len(massz_vec))
    Br_gg = np.zeros(len(massz_vec))
    Br_ww = np.zeros(len(massz_vec))
    Br_zz = np.zeros(len(massz_vec))
    Br_hh = np.zeros(len(massz_vec))
    Br_aa = np.zeros(len(massz_vec))
    Br_za = np.zeros(len(massz_vec))
    for t in range(len(massz_vec)):
        total_contribution = sigmav_channels(massz_vec[t],0.001,'tot')
        Br_cc[t] = sigmav_channels(massz_vec[t],0.001,'cc')/total_contribution
        Br_bb[t] = sigmav_channels(massz_vec[t],0.001,'bb')/total_contribution
        Br_tt[t] = sigmav_channels(massz_vec[t],0.001,'tt')/total_contribution
        Br_tautau[t] = sigmav_channels(massz_vec[t],0.001,'tautau')/total_contribution
        Br_gg[t] = sigmav_channels(massz_vec[t],0.001,'gg')/total_contribution
        Br_ww[t] = sigmav_channels(massz_vec[t],0.001,'ww')/total_contribution
        Br_zz[t] = sigmav_channels(massz_vec[t],0.001,'zz')/total_contribution
        Br_hh[t] = sigmav_channels(massz_vec[t],0.001,'hh')/total_contribution
        Br_aa[t] = sigmav_channels(massz_vec[t],0.001,'aa')/total_contribution
        Br_za[t] = sigmav_channels(massz_vec[t],0.001,'za')/total_contribution








.. GENERATED FROM PYTHON SOURCE LINES 68-69

Which we can further plot.

.. GENERATED FROM PYTHON SOURCE LINES 69-93

.. code-block:: default


    fig = plt.figure(figsize=(8,6))
    plt.plot(massz_vec,Br_cc, color='red', ls='--', lw=2.0, label=r'$c\bar{c}$' )
    plt.plot(massz_vec,Br_bb, color='blue', ls='-.', lw=2.0, label=r'$b\bar{b}$' )
    plt.plot(massz_vec,Br_tt, color='green', ls=':', lw=2.0, label=r'$t\bar{t}$' )
    plt.plot(massz_vec,Br_tautau, color='black', ls='-', lw=2.0, label=r'$\tau^+\tau^-$' )
    plt.plot(massz_vec,Br_gg, color='brown', ls='--', lw=2.0, label=r'$gg$' )
    plt.plot(massz_vec,Br_ww, color='red', ls='-.', lw=2.0, label=r'$W^+W^-$' )
    plt.plot(massz_vec,Br_zz, color='orange', ls='-.', lw=2.0, label=r'$ZZ$' )
    plt.plot(massz_vec,Br_hh, color='brown', ls=':', lw=2.0, label=r'$hh$' )
    plt.plot(massz_vec,Br_aa, color='purple', ls=':', lw=2.0, label=r'$\gamma\gamma$' )
    plt.plot(massz_vec,Br_za, color='cyan', ls=':', lw=2.0, label=r'$Z\gamma$' )
    plt.ylabel(r'$\langle \sigma v \rangle_i/\langle \sigma v \rangle_{\rm{TOT}}$', fontsize=18)
    plt.xlabel(r'$m_{\rm{S}}$ [GeV]', fontsize=18)
    plt.axis([2,1e4,1e-3,1.1])
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)
    plt.grid(True)
    plt.yscale('log')
    plt.xscale('log') 
    plt.legend(loc=4,prop={'size':14},numpoints=1, scatterpoints=1, ncol=1)
    fig.tight_layout(pad=0.5)
    plt.show()




.. image-sg:: /examples_gallery/images/sphx_glr_plot_annihilation_cross_section_001.png
   :alt: plot annihilation cross section
   :srcset: /examples_gallery/images/sphx_glr_plot_annihilation_cross_section_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 94-96

Furthermore, it is interesting to have a look at the thermal cross section.
We import the data file.

.. GENERATED FROM PYTHON SOURCE LINES 96-103

.. code-block:: default


    table_int = np.loadtxt(import_data_file('SHP_sigmav_table.dat'))
    sigmav_relic = np.zeros(len(massz_vec))
    for t in range(len(massz_vec)):
        lambda_val =  interpolate_relicdensity(massz_vec[t],'QCDB')
        sigmav_relic[t] = lambda2sigmav(massz_vec[t],lambda_val,table_int)








.. GENERATED FROM PYTHON SOURCE LINES 104-105

And we plot the :math:`\langle \sigma v \rangle` as a function of :math:`m_S`.

.. GENERATED FROM PYTHON SOURCE LINES 105-119

.. code-block:: default


    fig = plt.figure(figsize=(8,6))
    plt.plot(massz_vec,sigmav_relic, color='black', ls='--', lw=2.0, label=r'Thermal cross section' )
    plt.ylabel(r'$\langle \sigma v \rangle$ [cm$^3$/s]', fontsize=18)
    plt.xlabel(r'$m_{\rm{S}}$ [GeV]', fontsize=18)
    plt.axis([2,1e4,0.5*sigmav_relic.min(),2*sigmav_relic.max()])
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)
    plt.grid(True)
    plt.yscale('log')
    plt.xscale('log') 
    plt.legend(loc=4,prop={'size':14},numpoints=1, scatterpoints=1, ncol=1)
    fig.tight_layout(pad=0.5)
    plt.show()



.. image-sg:: /examples_gallery/images/sphx_glr_plot_annihilation_cross_section_002.png
   :alt: plot annihilation cross section
   :srcset: /examples_gallery/images/sphx_glr_plot_annihilation_cross_section_002.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  17.877 seconds)


.. _sphx_glr_download_examples_gallery_plot_annihilation_cross_section.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_annihilation_cross_section.py <plot_annihilation_cross_section.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_annihilation_cross_section.ipynb <plot_annihilation_cross_section.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
